// Use the "application" plugin. This Gradle plugin allows you to build executable Java applications.
apply plugin: "application"

// The following lines define some project metadata, like the version of the project as well as a description of what
// it does. Both of these properties are optional, but it's good practice to use them.
version = "1.0.0"
description = "An example Gradle project."

// This line lets the "application" plugin know what your main class is so it knows where to find
// the right main() method.
mainClassName = "com.github.einekatze.gradle_example.Main"

// The "repositories" section defines where Gradle should fetch project dependencies from.
repositories {
    // Load dependencies from JCenter, a service that hosts an incredible amount of libraries.
    jcenter()
}

// Tell Gradle which libraries the project depends on. Individual dependencies are often referred to as
// "artifacts" or "packages". The strings you see here are composed of three individual parts that, put together,
// uniquely identify the artifact:
//
//      - A group ID, usually a reversed domain name that may identify the author (e.g. ch.qos.logback)
//      - An artifact ID, which names the individual artifact (e.g. logback-classic)
//      - A version number (e.g. 1.1.3)
//
// Artifacts declared here with "compile" will be added to the application's classpath as it is compiled, and
// will be available if you run the application through Gradle, or make a distributable version of it using
// "distZip", "distTar" or "installDist".
//
// "testCompile" will make the dependency only get included in the build when you're running tests.
dependencies {
    // Add Logback, a logging framework.
    compile "ch.qos.logback:logback-classic:1.1.3"

    // When running tests, use JUnit.
    testCompile "junit:junit:4.12"
}

// This is needed by javadoc if you want to use umlauts or accents in your documentation.
javadoc {
    options.charSet = "UTF-8"
}